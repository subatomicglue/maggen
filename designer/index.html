<html>
  <head>
    <!-- https://getbootstrap.com/docs/4.0/getting-started/introduction/ -->
    <!--
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/js/bootstrap.min.js"></script>
    <script src="https://d3js.org/d3-selection.v1.min.js"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    -->
    
    <!-- https://getbootstrap.com/docs/4.0/getting-started/introduction/ -->
    <link rel="stylesheet" href="./external/bootstrap.min.css">
    <script src="./external/jquery.min.js"></script>
    <script src="./external/popper.min.js"></script>
    <script src="./external/bootstrap.min.js"></script>
    <script src="./external/d3-selection.v1.min.js"></script>
    <link href="./external/material-icons.css" rel="stylesheet">

    <script src="math.js"></script>
    <script src="svg.js"></script>
  </head>
  <body>
    <div class='container'>
    <div class="fixed-top bg-light text-left row px-2">
       <div class='col-10'>
          <a href='http://www.subatomiclabs.com'><img src='./mantis.png' width='32px' height='32px'></a> Axial Flux Generator Designer
       </div>
       <div class='text-right col-2'>
          <a href='https://github.com/subatomicglue/maggen'>github</a>
       </div>
    </div>
      <div class='row'>
      <fieldset>
        <legend>Axial Flux Generator Designer</legend>
         <!--<legend>Axial Flux Generator Designer (mm)</legend>-->
        <form onchange="draw()">
          <div class="card-columns">
            <!-- type="text" pattern="[0-9]+" maxlength="3" minlength="1" -->
            <!-- type="number" min="1" max="9999" -->
            <div class='card  text-nowrap'>
              <h3>Magnets</h3>
              <div class=''>
                  <label for="num_magnets">Number of Magnets</label>
                  <input type="number" id="num_magnets" name="num_magnets" placeholder="# magnets"
                        min="4" max="9999" step='1' value="12" required />
              </div>
              <div class=''>
                <label for="mag_shape">Shape of Magnet</label>
                <input type = "radio"
                      name = "mag_shape"
                      id = "shapeRect"
                      value = "rect"
                      checked = "checked" />
                <label for = "shapeRect">rect</label>
                <input type = "radio"
                      name = "mag_shape"
                      id = "shapeCircle"
                      value = "circle" />
                <label for = "shapeCircle">circle</label>
              </div>
              <div id='dia_magnet_group' class=''>
                  <label for="dia_magnet">Dia of Magnet</label>
                  <input type="number" id="dia_magnet" name="dia_magnet" placeholder="Magnet Dia"
                        min="1" max="9999" value="20" required />
              </div>
              <div id='w_magnet_group' class=''>
                  <label for="w_magnet">Magnet Width</label>
                  <input type="number" id="w_magnet" name="w_magnet" placeholder="Magnet Width"
                        min="1" max="9999" value="20" required />
              </div>
              <div id='h_magnet_group' class=''>
                  <label for="h_magnet">Magnet Height</label>
                  <input type="number" id="h_magnet" name="h_magnet" placeholder="Magnet Height"
                        min="1" max="9999" value="15" required />
              </div>
              <div class=''>
                  <label for="mag_mid_dia">Magnet Placement Diameter</label>
                  <input type="number" id="mag_mid_dia" name="mag_mid_dia" placeholder="Mag Mid Dia"
                        min="1" max="9999" value="90" required />
              </div>
            </div>
            <div class='card  text-nowrap'>
              <h3>Disc</h3>
              <div class=''>
                  <label for="outside_dia">Outside Diameter</label>
                  <input type="number" id="outside_dia" name="outside_dia" placeholder="Outside Dia"
                        min="1" max="9999" value="130" required />
              </div>
              <div class=''>
                  <label for="in_dia">Coil Disc Inside Diameter</label>
                  <input type="number" id="in_dia" name="in_dia" placeholder="Inside Dia"
                        min="1" max="9999" value="22" required />
              </div>
              <div class=''>
                  <label for="in_dia2">Magnet Disc Inside Diameter</label>
                  <input type="number" id="in_dia2" name="in_dia2" placeholder="Inside Dia"
                        min="1" max="9999" value="8" required />
              </div>
              <div class=''>
                  <label for="num_disc_holes">Magnet Disc Mounting Holes</label>
                  <input type="number" id="num_disc_holes" name="num_disc_holes" placeholder="Holes"
                        min="1" max="9999" value="8" required />
              </div>
              <div class=''>
                  <label for="discmount_hole_size_dia">Magnet Disc Single Hole Size (dia)</label>
                  <input type="number" id="discmount_hole_size_dia" name="discmount_hole_size_dia" placeholder="Hole Size Dia"
                        min="1" max="9999" value="3" required />
              </div>
              <div class=''>
                  <label for="discmount_hole_placement_dia">Magnet Disc Hole Placement (dia)</label>
                  <input type="number" id="discmount_hole_placement_dia" name="discmount_hole_placement_dia" placeholder="Hole Placement Dia"
                        min="1" max="9999" value="20" required />
              </div>
            </div>
            <div class='card  text-nowrap'>
              <h3>Coil</h3>
              <div class=''>
                <label for="coil_type">Type of Coil</label>
                <input type = "radio"
                      name = "coil_type"
                      id = "coilSerpentine"
                      value = "serpintine"
                      checked = "checked" />
                <label for = "coilSerpentine">serpentine</label>
                <input type = "radio"
                      name = "coil_type"
                      id = "coilLoops"
                      value = "loops"  />
                <label for = "coilLoops">loops</label>
              </div>
              <div id='num_serpents_group' class=''>
                  <label for="num_serpents">Coil Overlap</label>
                  <input type="number" id="num_serpents" name="num_serpents" placeholder="# serpents"
                        min="1" max="9999" step='1' value="1" required />x
              </div>
              <div id='num_loops_group' class=''>
                  <label for="num_loops">Number of Coils</label>
                  <input type="number" id="num_loops" name="num_loops" placeholder="# loops"
                        min="4" max="9999" step='1' value="12" required />
                  <input type="checkbox" class="form-check-input position-static" data-toggle="tooltip" id="lock_coil_number" title='Lock to Number of Magnets' checked/>
              </div>
              <div id='num_coiloverlap_group' class=''>
                  <label for="num_coiloverlaps">Coil Overlap</label>
                  <input type="number" id="num_coiloverlaps" name="num_coiloverlaps" placeholder="X overlaps"
                        min="1" max="9999" step='1' value="1" required />x
              </div>
              <div class=''>
                  <label for="mag_out_dia">Coil Outside Diameter</label>
                  <input type="number" id="mag_out_dia" name="mag_out_dia" placeholder="Coil Outside Dia"
                        min="1" max="9999" value="128" required />
              </div>
              <div class=''>
                  <label for="mag_in_dia">Coil Inside Diameter</label>
                  <input type="number" id="mag_in_dia" name="mag_in_dia" placeholder="Coil Inside Diameter"
                        min="1" max="9999" value="58" required />
              </div>
              <div class=''>
                  <label for="coil_thickness">Coil Thickness (dia)</label>
                  <input type="number" id="coil_thickness" name="coil_thickness" placeholder="Coil Thickness"
                        min="1" max="9999" value="6" required />
              </div>
            </div>
          </div>
        </form>
      </fieldset>
    </div>
    <div class='row'>
      <div id='errors' style="color:red"></div>
    </div>
    <div class='row'>
      <div class='col-sm bg-primary p-0 m-0'>
        <div style='background-color: #333333;'>
          <svg id="svg" viewBox="-100 -100 100 100">
            <!--<rect width="100%" height="100%" fill="grey"/>-->
          </svg>
        </div>
      </div>
      <div class='col-sm'>
        <a id='download' class='btn btn-primary pointer btn-lg active' href="">Download .svg</a>
        <div>Legend:</div>
        <ul>
        <div style="color:#ff00aa">wire winder tool</div>
        <div style="color:#ff9900">wire</div>
        <div style="color:#99bbff">magnets</div>
        <div style="color:#aaaaaa">rotor/stator disc(s), resin mold</div>
        </ul>
        <button type="button" class="btn btn-dark" onclick="onAnimate()">Animate</button>
        <!-- settings panel -->
        <button class="btn btn-primary" type="button" data-toggle="collapse" data-target="#collapseSettings" aria-expanded="false" aria-controls="collapseSettings"><i class="material-icons">settings</i></button>
        <fieldset class="collapse" id="collapseSettings">
          <form onchange="draw()">
            <div class='card  text-nowrap'>
              <h3>Settings</h3>
              <div class=''>
                <label for="line_thickness">Line Thickness</label>
                <input type="number" id="line_thickness" name="line_thickness" placeholder="thickness"
                       min="0.05" max="3" step='0.05' value="0.4" required />
              </div>
            </div>
          </form>
        </fieldset>
      </div>
    </div>
    </div>
    <style>
      @media (min-width: 576px) {
        .card-columns { column-count: 2; }
      }
      @media (min-width: 768px) {
        .card-columns { column-count: 2; }
      }
      @media (min-width: 992px) {
        .card-columns { column-count: 3; }
      }
      @media (min-width: 1200px) {
        .card-columns { column-count: 3; }
      }
      .rot {
        animation: rot 30.0s linear infinite;
      }
      @keyframes rot {
        0% {
          -webkit-transform:  rotate(180deg) rotate(0deg);
          -moz-transform:  rotate(180deg) rotate(0deg);
          transform: rotate(180deg) rotate(0deg);
        }
        100% {
          -webkit-transform:  rotate(180deg) rotate(360deg);
          -moz-transform:  rotate(180deg) rotate(360deg);
          transform: rotate(180deg) rotate(360deg);
        }
      }
    </style>
    <script>
      let c0 = "#aaaaaa";
      let c1 = "#99bbff";
      let c1b = "#99bb00";
      let c2 = "#ff9900";
      let c3 = "#ff00aa";

      // make a serpent shaped wire coil
      // coilt is the offset used for coilthickness (call makeSerpent multiple times)
      // return path (that is appended with the new serpent)
      // return coilWinderCircumference
      function makeSerpent( rot, pos, num_magnets, mag_in_dia, mag_out_dia, coilt ) {
         let path = []
         let coilWinderCircumference = 0;
         let arc_len_deg = 360/(num_magnets*0.5);
         let arc_len_rad = arc_len_deg * Math.PI/180;
         for (let x = 0; x < (num_magnets/2); ++x) {
            // generate some arc stats for this iteration
            let s = rot + x * arc_len_rad;
            let s1d = arc_len_rad*0.5;
            let s1 = s+s1d;
            let s2d = arc_len_rad;
            let s2 = s+s2d;
            let sneg = s-s1d;
            //   2 3
            // 0 1 4 5
            let inner_start_prev= radialToCartesian( pos.x,pos.y, mag_in_dia/2, sneg );
            let inner_end_prev  = radialToCartesian( pos.x,pos.y, mag_in_dia/2, s );
            let outer_start     = radialToCartesian( pos.x,pos.y, mag_out_dia/2, s );
            let outer_end       = radialToCartesian( pos.x,pos.y, mag_out_dia/2, s1 );
            let inner_start     = radialToCartesian( pos.x,pos.y, mag_in_dia/2, s1 );
            let inner_end       = radialToCartesian( pos.x,pos.y, mag_in_dia/2, s2 );
            let rt = mul( perp( dir( inner_end_prev, outer_start ) ), vec( coilt ) );
            let lt = mul( perp( dir( outer_end, inner_start ) ), vec( coilt ) );
            let dnp = mul( perp( dir( inner_start_prev, inner_end_prev ) ), vec( coilt ) );
            let dn = mul( perp( dir( outer_start, outer_end ) ), vec( coilt ) );
            let dnn = mul( perp( dir( inner_start, inner_end ) ), vec( coilt ) );
            let ox=0, oy=0; // in case you need an offset... here it is, move it up to the inputs.
            let p0 = add( line_intersect( add( inner_start_prev, dnp ), add( inner_end_prev, dnp ),
                                          add( inner_end_prev, rt ), add( outer_start, rt ) ), vec(ox,oy) );
            let p1 = add( line_intersect( add( inner_end_prev, rt ), add( outer_start, rt ),
                                          add( outer_start, dn ), add( outer_end, dn ) ), vec(ox,oy) );
            let p2 = add( line_intersect( add( outer_start, dn ), add( outer_end, dn ),
                                          add( outer_end, lt ), add( inner_start, lt ) ), vec(ox,oy) );
            let p3 = add( line_intersect( add( outer_end, lt ), add( inner_start, lt ),
                                          add( inner_start, dnn ), add( inner_end, dnn ) ), vec(ox,oy) );
            path.push( p0 );
            path.push( p1 );
            path.push( p2 );
            path.push( p3 );
            coilWinderCircumference += dist( inner_end_prev, outer_start );
            coilWinderCircumference += dist( outer_start, outer_end );
            coilWinderCircumference += dist( outer_end, inner_start );
            coilWinderCircumference += dist( inner_start, inner_end );
         }

         // approx radius for the coil winder
         let coilWinderRadius = (coilWinderCircumference / (2*Math.PI));
         return {path, coilWinderRadius};
      }

      // as much as we can, unwind the serpentine so we have a big (almost round) polygon,
      // so it will tend to crimp the wire in the right places to guide in bending the serpentine shape
      function makeSerpentWinder( rot, pos, num_magnets, mag_in_dia, mag_out_dia, coilWinderRadius, coilt ) {
         coilWinderRadius += coilt;
         let path = [];
         let arc_len_deg = 360/(num_magnets*0.5);
         let arc_len_rad = arc_len_deg * Math.PI/180;

         for (let x = 0; x < (num_magnets/2 - 0.5); ++x) {
            // generate some arc stats for this iteration
            let s = rot + x * arc_len_rad;
            let s1d = arc_len_rad*0.5;
            let s1 = s+s1d;
            let s2d = arc_len_rad;
            let s2 = s+s2d;
            // 0 1
            //   2 3
            let outer_start     = radialToCartesian( pos.x,pos.y, mag_out_dia/2, s );
            let outer_end       = radialToCartesian( pos.x,pos.y, mag_out_dia/2, s1 );
            let inner_start     = radialToCartesian( pos.x,pos.y, mag_in_dia/2, s1 );
            let inner_end       = radialToCartesian( pos.x,pos.y, mag_in_dia/2, s2 );

            // we're going to project (move w/ no scale) 2 segments to the coilWinderRadius circle
            // the outer and the inner segments.  The segments inbetween will magically appear correct. :)
            // * get each segment's length
            let outer_length = dist( outer_start, outer_end );
            let inner_length = dist( inner_start, inner_end );
            // * coilWinderRadius circle is always larger than mag_out_dia
            //   if we pushed the 'outer' (or 'inner') segment out to the larger coilWinderRadius circle (same seg length)
            //   calc the (now narrower) angle that sweeps the segment length (we'll calc the half angle using TOA)
            //     a  |      |\
            // o------|------|s) <-- coilWinderRadius
            //  t     |     o|/
            // coilWinderRadius goes to the circle, so calculate the slightly shorter length to the segment center
            // height of the arc above the seg is called the sagitta: https://www.mathopenref.com/sagitta.html
            // s = r +/- sqrt( radius^2 - i^2 )   where i is 1/2 the segment length
            let outer_sagitta = coilWinderRadius - Math.sqrt( sqr(coilWinderRadius) - sqr(outer_length * 0.5) )
            let inner_sagitta = coilWinderRadius - Math.sqrt( sqr(coilWinderRadius) - sqr(inner_length * 0.5) )
            let outer_rad_half = Math.atan( outer_length * 0.5 / (coilWinderRadius - outer_sagitta) ); // tan(t) = o/a    (soh/cah/toa)
            let inner_rad_half = Math.atan( inner_length * 0.5 / (coilWinderRadius - inner_sagitta) );
            // * calc the angle that passes through each segment's center point
            let s_s1 = s + s1d / 2;
            let s1_s2 = s1 + s1d / 2;
            // * calc the points for 3 segments, add to the path (4th segment we get for free next iteration)
            let p0 = radialToCartesian( pos.x,pos.y, coilWinderRadius, s_s1 - outer_rad_half );
            let p1 = radialToCartesian( pos.x,pos.y, coilWinderRadius, s_s1 + outer_rad_half );
            let p2 = radialToCartesian( pos.x,pos.y, coilWinderRadius, s1_s2 - inner_rad_half );
            let p3 = radialToCartesian( pos.x,pos.y, coilWinderRadius, s1_s2 + inner_rad_half );
            path.push( p0 );
            path.push( p1 );
            path.push( p2 );
            path.push( p3 );
         }
         return {path};
      }

      // create one single-coil loop
      function makeLoop( ox, oy, x, pos, rot, num_magnets, mag_in_dia, mag_out_dia, coilt ) {
         let path = [];
         let arc_len_deg = 360/num_magnets;
         let arc_len_rad = arc_len_deg * Math.PI/180;

         // generate some arc stats for this iteration
         let s = rot + x * arc_len_rad;
         let s1d = arc_len_rad;
         let s1 = s+s1d;
         // 1 2
         // 0 3
         let inner_end_prev  = radialToCartesian( pos.x,pos.y, mag_in_dia/2, s );
         let outer_start     = radialToCartesian( pos.x,pos.y, mag_out_dia/2, s );
         let outer_end       = radialToCartesian( pos.x,pos.y, mag_out_dia/2, s1 );
         let inner_start     = radialToCartesian( pos.x,pos.y, mag_in_dia/2, s1 );
         let up1 = mul( dir( outer_start, inner_end_prev ), vec( coilt ) );
         let up2 = mul( dir( outer_end, inner_start ), vec( coilt ) );
         let dn1 = inv( up1 );
         let dn2 = inv( up2 );
         let lt = mul( dir( outer_start, outer_end ), vec( coilt ) );
         let rt = mul( dir( outer_end, outer_start ), vec( coilt ) );

         let p0 = add( add( add( inner_end_prev, up1 ), rt ), vec(ox,oy) );
         let p1 = add( add( add( outer_start, dn1 ),    rt ), vec(ox,oy) );
         let p2 = add( add( add( outer_end, dn2 ),      lt ), vec(ox,oy) );
         let p3 = add( add( add( inner_start, up2 ),    lt ), vec(ox,oy) );
         path.push(p0);
         path.push(p1);
         path.push(p2);
         path.push(p3);
         path.push(p0);
         return {path};
      }

      // create all the single-coil loops in a ring
      function makeLoops( pos, rot, num_magnets, mag_in_dia, mag_out_dia, coilt ) {
         let paths = [];
         for (let x = 0; x < num_magnets; ++x) {
            paths.push( makeLoop( 0,0, x, pos, rot, num_magnets, mag_in_dia, mag_out_dia, coilt ).path );
         }
         return {paths};
      }

      // draw the diagram into the <svg>
      function draw() {
        errors.innerHTML = '';

        // update controls
        dia_magnet_group.hidden = !shapeCircle.checked;
        w_magnet_group.hidden = shapeCircle.checked;
        h_magnet_group.hidden = shapeCircle.checked;
        num_serpents_group.hidden = !coilSerpentine.checked;
        num_loops_group.hidden = coilSerpentine.checked;
        num_coiloverlap_group.hidden = coilSerpentine.checked;
        if (lock_coil_number.checked)
          num_loops.value = num_magnets.value;

        // construct the svg
        clearSvg( svg );
        let svgdebug = newPath( svg, "svgdebug" );

        let vwidth = 0, vheight = 0;
        let pos = { x: 0, y: 0 };

        // disc geometry
        addPath( 'svg', 'disc_out', c0, +line_thickness.value, circlePath( pos.x,pos.y, outside_dia.value/2 ) )
        addPath( 'svg', 'disc_in', c0, +line_thickness.value, circlePath( pos.x,pos.y, in_dia.value/2 ) )
        addPath( 'svg', 'disc_in2', c0, +line_thickness.value, circlePath( pos.x,pos.y, in_dia2.value/2 ) )

        let discmount_hole_paths = [];
        for (let hole = 0; hole < +num_disc_holes.value; ++hole) {
          let rot = (hole/+num_disc_holes.value) * 2 * Math.PI;
          let holep = radialToCartesian( pos.x,pos.y, +discmount_hole_placement_dia.value/2, rot );
          discmount_hole_paths.push( circlePath( holep.x,holep.y, +discmount_hole_size_dia.value / 2 ) );
        }
        addPath( 'svg', 'disc_holes', c0, +line_thickness.value, discmount_hole_paths.join(' ') )

        // wire geometry
        if (coilSerpentine.checked && +num_magnets.value % 2 == 1) errors.innerHTML = "ERROR: for serpentine coils, please give an even number of magnets";
        if (coilLoops.checked && +num_magnets.value % 2 == 1) errors.innerHTML = "ERROR: for loop coils, please give an even number of magnets";
        {
          let result;

          // one big loop of wire (minimize waste, easier to wind, etc.)
          if (coilSerpentine.checked) {
            let coilWinderRadius;
            let coilt = +coil_thickness.value;
            let mod = +mag_out_dia.value - coilt;
            let mid = +mag_in_dia.value + coilt;
            for (let snake = 0; snake < +num_serpents.value; ++snake) {
              let rotoffset = (1/+num_magnets.value) * (snake/(+num_serpents.value)) * 2 * Math.PI;

              result = makeSerpent( rotoffset, pos, +num_magnets.value, mid, mod, 0 );
              //addPath( 'svg', `coil_center${snake}`, c2, +line_thickness.value, vecArrayToSvgPathData( result.path ) );

              // capture one of these for later...
              if (coilWinderRadius == undefined)
                coilWinderRadius = result.coilWinderRadius;

              result = makeSerpent( rotoffset, pos, +num_magnets.value, mid, mod, coilt * 0.5 );
              addPath( 'svg', `coil_out${snake}`, c2, +line_thickness.value, vecArrayToSvgPathData( result.path ) );

              result = makeSerpent( rotoffset, pos, +num_magnets.value, mid, mod, -coilt * 0.5 );
              addPath( 'svg', `coil_in${snake}`, c2, +line_thickness.value, vecArrayToSvgPathData( result.path ) );
            }

            result = makeSerpentWinder( 0, pos, +num_magnets.value, mid, mod, coilWinderRadius - coilt * 0.5, 0 );
            addPath( 'svg', `winder_inner`, c3, +line_thickness.value, vecArrayToSvgPathData( result.path ) );
            result = makeSerpentWinder( 0, pos, +num_magnets.value, mid, mod, coilWinderRadius - coilt * 0.5, coilt );
            addPath( 'svg', `winder_outer`, c3, +line_thickness.value, vecArrayToSvgPathData( result.path ) );

            // lazy approach, just make the winder a pure circle
            // (inaccurate because the serpentine is chunky-polygonal, not smooth-curved,
            //  so your wire loop'll be _slightly_ too long this way)
            //setPath( c3, svgwrappath, circlePath( pos.x, pos.y, coilWinderRadius ) );

            // setup the svg's viewbox so it zooms in nice
            vwidth = vheight = Math.max( (coilWinderRadius + coilt) * 2, outside_dia.value );
          } else {
            for (let overlap = 0; overlap < +num_coiloverlaps.value; ++overlap) {
              let rot = overlap * (2 * Math.PI / +num_loops.value) / +num_coiloverlaps.value;
              result = makeLoops( pos, rot, +num_loops.value, +mag_in_dia.value, +mag_out_dia.value, 0 );
              addPath( 'svg', `coils_outer${overlap}${0}`, c2, +line_thickness.value, arrayOfVecArraysToSvgPathData( result.paths ) );
              result = makeLoops( pos, rot, +num_loops.value, +mag_in_dia.value, +mag_out_dia.value, +coil_thickness.value );
              addPath( 'svg', `coils_inner${overlap}${0}`, c2, +line_thickness.value, arrayOfVecArraysToSvgPathData( result.paths ) );
            }

            // winder
            result = makeLoop( -4,4, 0, pos, 0, +num_loops.value, +mag_in_dia.value, +mag_out_dia.value, 0 );
            addPath( 'svg', `winder_outer`, c3, +line_thickness.value, vecArrayToSvgPathData( result.path ) );
            result = makeLoop( -4,4, 0, pos, 0, +num_loops.value, +mag_in_dia.value, +mag_out_dia.value, +coil_thickness.value );
            addPath( 'svg', `winder_inner`, c3, +line_thickness.value, vecArrayToSvgPathData( result.path ) );

            // setup the svg's viewbox so it zooms in nice
            vwidth = vheight = +outside_dia.value;
          }
        }

        // magnet geometry
        {
          let path1 = [];
          let path2 = [];
          for (let x = 0; x < +num_magnets.value; ++x) {
            let path;
            let arc_len_deg = 360/(+num_magnets.value*0.5);
            let arc_len_rad = arc_len_deg * Math.PI/180;
            let s = x * arc_len_rad*0.5;
            let mag_centerN = radialToCartesian( pos.x,pos.y, mag_mid_dia.value/2, s );
            if (shapeCircle.checked) {
              path = circlePath( mag_centerN.x, mag_centerN.y, dia_magnet.value*0.5 );
            } else {
              path = rectPath( mag_centerN.x, mag_centerN.y, w_magnet.value, h_magnet.value, s );
            }
            if (x % 2 === 1)
              path1.push( path );
            else
              path2.push( path );
          }
          addPath( 'svg', `svgmagpath`, c1, +line_thickness.value, path1.join(' ') );
          addPath( 'svg', `svgmagpath2`, c1b, +line_thickness.value, path2.join(' ') );
        }
        svg.setAttribute( 'viewBox', `${- +vwidth/2 - 2} ${- +vheight/2 - 2} ${+vwidth + 4} ${+vheight + 4}` );
        createSVGDownload( svg, download );
      }
      function init() {
        draw();
      }
      window.onload = init();
      //init();
    </script>

  </body>
</html>

